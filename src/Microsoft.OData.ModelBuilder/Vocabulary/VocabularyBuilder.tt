<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="Microsoft.OData.Edm" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.OData.Edm" #>
<#@ import namespace="Microsoft.OData.Edm.Csdl" #>
<#@ import namespace="Microsoft.OData.Edm.Vocabularies" #>
<#@ output extension=".cs" #>
<#
	var model = new EdmModel().ReferencedModels.FirstOrDefault(m => m.GetNamespaceAlias("Org.OData.Capabilities.V1") != null);
	if (model == null)
	{
		throw new InvalidOperationException("The Capabilities Model Cannot Be Found");
	}

	var manager = new Manager(this, model);
	var namespaces = manager.Process();
#>
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License.  See License.txt in the project root for license information.
// This is an auto generated file. Please run the template to modify it.

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.OData.Edm;
using Microsoft.OData.Edm.Vocabularies;

<#
	foreach(var ns in namespaces)
	{
		WriteLine($"using {ns};");
	}
#>

namespace Microsoft.OData.ModelBuilder
{
	/// <summary>
	/// Interface for clr types that can be converted into <see cref="EdmRecordExpression" />
	/// </summary>
	public interface IRecord
	{
        /// <summary>
        /// Convert a clr type to an <see cref="IEdmExpression" />
        /// </summary>
        /// <returns><see cref="IEdmExpression" /></returns>
		IEdmExpression ToEdmExpression();
	}

    /// <summary>
    /// Base vocabulary builder.
    /// </summary>
	public abstract partial class VocabularyBuilder : IRecord
	{
		private readonly string _termName;

        /// <summary>
        /// Creates a new instance of <see cref="VocabularyBuilder"/>
        /// </summary>
        /// <param name="termName">The name of the <see cref="IEdmTerm"/> being built.</param>
		public VocabularyBuilder(string termName) => _termName = termName;

		/// <inheritdoc/>
		public abstract IEdmExpression ToEdmExpression();

        /// <summary>
        /// Sets the vocabulary annotation on the model's target.
        /// </summary>
        /// <param name="model">The <see cref="IEdmModel"/> having reference vocabulary models.</param>
        /// <param name="target">The <see cref="IEdmVocabularyAnnotatable"/> to set annotations on.</param>
		public virtual void SetVocabularyAnnotations(EdmModel model, IEdmVocabularyAnnotatable target)
		{
			_ = model ?? throw new ArgumentNullException(nameof(model));
			_ = target ?? throw new ArgumentNullException(nameof(target));

			var expression = ToEdmExpression();
			if (expression == null)
			{
				return;
			}

			var term = model.FindTerm(_termName);
			if (term == null)
			{
				return;
			}

			var annotation = new EdmVocabularyAnnotation(target, term, expression);
			model.SetVocabularyAnnotation(annotation);
		}
	}

	/// <summary>
	/// Extension methods for vocabulary builders configurations
	/// </summary>
	public static class VocabularyBuilderExtensions
	{
<#
		foreach (var term in model.SchemaElements.OfType<IEdmTerm>())
		{
#>
		/// <summary>
		/// <see cref="<#= term.Name #>Builder"/> configuration
		/// </summary>
		/// <typeparam name="TEntity">The entity type of the navigation source.</typeparam>
		/// <param name="navigationSource">The <see cref="IEdmNavigationSource"/> that can be built using <see cref="ODataModelBuilder"/>.</param>
		/// <returns><see cref="<#= term.Name #>Builder"/></returns>
		public static <#= term.Name #>Builder Has<#= term.Name #><TEntity>(this NavigationSourceConfiguration<TEntity> navigationSource) where TEntity : class
			=> navigationSource?.GetVocabularyBuilder<<#= term.Name #>Builder, TEntity>();

<#
		}
#>
		/// <summary>
		/// Apply all builders as configured
		/// </summary>
        public static void SetVocabularyBuilderAnnotations(this EdmModel model, EdmNavigationSource target, NavigationSourceConfiguration configuration)
        {
            _ = model ?? throw Error.ArgumentNull(nameof(model));
            if (target == null || configuration == null)
            {
                return;
            }

			foreach (var builder in configuration.VocabularyBuilders.Values)
			{
				builder.SetVocabularyAnnotations(model, (IEdmVocabularyAnnotatable)target);
			}
        }

		private static TBuilder GetVocabularyBuilder<TBuilder, TEntity>(this NavigationSourceConfiguration<TEntity> navigationSource) where TBuilder : VocabularyBuilder, new() where TEntity : class
        {
            var vocabularyBuilders = navigationSource.Configuration.VocabularyBuilders;
            if (vocabularyBuilders.TryGetValue(typeof(TBuilder), out var builder))
            {
                return builder as TBuilder;
            }

            builder = new TBuilder();
            vocabularyBuilders.Add(typeof(TBuilder), builder);

            return (TBuilder)builder;
        }
	}
}

<#+
class Manager : GeneratedTextTransformation
{
	private readonly Dictionary<string, (string Namespace, string FilePath)> _namespaceMap = new Dictionary<string, (string, string)>();
	private readonly string _templateDirectory;
	private readonly IEdmModel _model;

	public Manager(GeneratedTextTransformation transformation, IEdmModel model)
	{
		_templateDirectory = Path.GetDirectoryName(transformation.Host.TemplateFile);
		_model = model;
	}

	public IEnumerable<string> Process()
	{
		foreach (var term in _model.SchemaElements.OfType<IEdmTerm>())
		{
			WriteTerm(term);
		}

		return _namespaceMap.Values.Select(v => v.Namespace).Distinct();
	}

	public void WriteTerm(IEdmTerm term)
	{
		WriteHeader();
#>
namespace <#= GetNamespace(term) #>
{
	/// <summary>
	<#+ ProcessSummary(term, "	"); #>
	/// </summary>
	public partial class <#= term.Name #>Builder : VocabularyBuilder
	{
        /// <summary>
        /// Creates a new instance of <see cref="<#= term.Name #>Builder"/>
        /// </summary>
		public <#= term.Name #>Builder()
			: base("<#= term.FullName()#>")
		{
		}

		/// <inheritdoc/>
		public override IEdmExpression ToEdmExpression()
		{
			return null;
		}
	}
}
<#+
		Dump(term);
	}

	public void WriteHeader()
	{
#>
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License.  See License.txt in the project root for license information.
// This is an auto generated file. Please run the template to modify it.

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.OData.Edm;
using Microsoft.OData.Edm.Vocabularies;

<#+
	}

	public void WriteClass()
	{
		
	}

	private void ProcessSummary(IEdmVocabularyAnnotatable target, string indent)
	{
		var description = _model.GetDescriptionAnnotation(target) ?? target.ToString();
		ProcessSummary(description, indent);
	}

	private void ProcessSummary(string text, string indent)
	{
		if (string.IsNullOrEmpty(text))
		{
			WriteLine("/// Summary");
		}
		var lines = text.Split(new char[] { '\r', '\n' });
		WriteLine($"/// {lines.FirstOrDefault()}");
		foreach (var line in lines.Skip(1))
		{
			WriteLine($"{indent}/// {line}");
		}
	}

	private string GetNamespace(IEdmSchemaElement element) => GetFileDetails(element).Namespace;	

	private string GetFilePath(IEdmSchemaElement element) => GetFileDetails(element).FilePath;	

	private (string Namespace, string FilePath) GetFileDetails(IEdmSchemaElement element)
	{
		var key = element.FullName();
		if (_namespaceMap.TryGetValue(key, out var details))
		{
			return details;
		}

		var vocabulary = element.Namespace.Replace("Org.OData", string.Empty);
		var @namespace = $"Microsoft.OData.ModelBuilder{vocabulary}";
		var fileParts = vocabulary.Split(new char[]{'.'}, StringSplitOptions.RemoveEmptyEntries).ToList();
		fileParts.Insert(0, _templateDirectory);
		fileParts.Add($"{element.Name}Builder.cs");
		var filePath = Path.Combine(fileParts.ToArray());

		details = (@namespace, filePath);
		_namespaceMap.Add(key, details);

		return details;
	}

	private void Dump(IEdmSchemaElement element)
	{
		var filePath = GetFilePath(element);
		Directory.CreateDirectory(Path.GetDirectoryName(filePath));
		File.WriteAllText(GetFilePath(element), this.GenerationEnvironment.ToString());
		this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
	}
}
#>